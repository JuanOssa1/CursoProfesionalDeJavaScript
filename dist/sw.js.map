{"version":3,"sources":["sw.js"],"names":["VERSION","self","addEventListener","event","waitUntil","precache","request","method","respondWith","cachedResponse","updateCache","cache","caches","open","addAll","response","match","fetch","status","put"],"mappings":"AAAA;AACA,MAAMA,OAAO,GAAG,IAAhB;AACAC,IAAI,CAACC,gBAAL,CAAsB,SAAtB,EAAiCC,KAAK,IAAI;AACtC;;;AAGAA,EAAAA,KAAK,CAACC,SAAN,CAAgBC,QAAQ,EAAxB;AACH,CALD;AAMA;;AACAJ,IAAI,CAACC,gBAAL,CAAsB,OAAtB,EAA+BC,KAAK,IAAI;AACpC,QAAMG,OAAO,GAAGH,KAAK,CAACG,OAAtB,CADoC,CAEpC;;AACA;;;;AAGA;;;;;;;AAMAA,EAAAA,OAAO,CAACC,MAAR,KAAmB,KAAnB,GAA2BJ,KAAK,CAACK,WAAN,CAAkBC,cAAc,CAACH,OAAD,CAAhC,CAA3B,GAAwE,IAAxE;AAEA;;AACAH,EAAAA,KAAK,CAACC,SAAN,CAAgBM,WAAW,CAACJ,OAAD,CAA3B;AAEH,CAjBD;;AAqBA,eAAeD,QAAf,GAAyB;AACrB;;;;AAIA,QAAMM,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,OAAZ,CAApB;AACA,SAAOW,KAAK,CAACG,MAAN,CAAa;AACpB;;;;;;;;;;AADoB,GAAb,CAAP;AAYH;;AACD,eAAeL,cAAf,CAA+BH,OAA/B,EAAwC;AACpC,QAAMK,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,OAAZ,CAApB;AACA;;;;;AAIA,QAAMe,QAAQ,GAAG,MAAMJ,KAAK,CAACK,KAAN,CAAYV,OAAZ,CAAvB;AACA;;;;AAGA;;AACA,SAAOS,QAAQ,IAAIE,KAAK,CAACX,OAAD,CAAxB;AACA;;;;AAIH;;AAED,eAAeI,WAAf,CAA2BJ,OAA3B,EAAoC;AAChC,QAAMK,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,OAAZ,CAApB;AACA,QAAMe,QAAQ,GAAG,MAAME,KAAK,CAACX,OAAD,CAA5B;AACA,SAAOS,QAAQ,CAACG,MAAT,KAAoB,GAApB,GAA0BP,KAAK,CAACQ,GAAN,CAAUb,OAAV,EAAmBS,QAAnB,CAA1B,GAAyD,IAAhE;AAEH","file":"sw.js","sourceRoot":"..","sourcesContent":["/**Instala este service workker en el navegador */\nconst VERSION = \"v1\"\nself.addEventListener('install', event => {\n    /**\n     * aqui creo la cache y espero a que se complete, es decir, espera a que la promesa se complete\n     */\n    event.waitUntil(precache());\n})\n/**Ahora para llamar en la cache:*/\nself.addEventListener('fetch', event => {\n    const request = event.request;\n    //solo nos interesa usar la cache con el get porque los demas metodos \n    /**tienen iinformacion que no debe ser almacenada ahi porque no se\n     * usa\n     */\n    /*\n    if(request.method !== 'GET'){\n        return\n    }\n    event.respondWith(cachedResponse(request));\n    */\n    request.method === \"GET\" ? event.respondWith(cachedResponse(request)) : true\n\n    /**Aqui actualizamos el cache para que no se quede con versiones viejas*/\n    event.waitUntil(updateCache(request));\n\n});\n\n\n\nasync function precache(){\n    /**Esto nos da una instancia de un cache  y pues\n     * adentro va el nombre de la version que le definimos se le pone await y async\n     * porque esto lo que retorna es una promesa\n     */\n    const cache = await caches.open(VERSION);\n    return cache.addAll([  \n    /*\n        '/',\n    '/index.html',\n    '/assets/index.js',\n    '/assets/MediaPlayer.js',\n    '/assets/plugins/AutoPlay.js',\n    '/assets/plugins/AutoPause.js',\n    '/assets/index.css',\n    '/assets/BigBuckBunny.mp4',\n    */\n    ])\n}\nasync function cachedResponse (request) {\n    const cache = await caches.open(VERSION);\n    /**A   Arriba hago una instancia de la cahce y abajo lo que hago\n     * es hacerle un request que normalmente haria en internet normal al cache para ver si este\n     * lo tiene almacenado\n    */\n    const response = await cache.match(request);\n    /**Y aqui hace el fecth que es el que me trae toda informacion en caso\n     * de que la informacion no este en el cache\n     */\n    /**y el || lo que hace es que si lo primero es falso o undefined retorna lo de la derecha */\n    return response || fetch(request);\n    /**El problema de usar cache asi por mas es que si actualizamos el index\n     * pero ya hay uno en cache seguira tomando el de cache y no hhara las actualizaciones\n     * nuevas para eevitar esto hacemos un metodo que busque y actualice la cache \n     */\n}\n\nasync function updateCache(request) {\n    const cache = await caches.open(VERSION);\n    const response = await fetch(request);\n    return response.status === 200 ? cache.put(request, response) : true;\n    \n}"]}